import { Meta } from "@storybook/blocks";

<Meta title="Component Guide" />

# Component Guide

This guide provides best practices and patterns for using components from the Orion Task System library.

## üéØ Component Categories

### UI Components (`components/ui/`)

These are the foundational building blocks of the design system. They are:
- **Reusable** across different contexts
- **Composable** to build more complex components
- **Themeable** supporting light/dark modes
- **Accessible** with proper ARIA labels

**Examples:**
- `Button` - For actions
- `Card` - For grouping content
- `TextField` - For text input
- `DatePicker` - For date selection

**When to use:** Use these components whenever you need basic UI elements. They provide consistent styling and behavior across the app.

### Domain Components (`components/`)

Domain-specific components that understand the business logic of tasks and appointments:
- **TaskCard** - Displays task information with status and actions
- **AppointmentCard** - Shows appointment details with date/time
- **GroupedTasksView** - Organizes tasks by date and time
- **TaskFilters** - Provides filtering UI for task lists

**When to use:** Use these components when working with task or appointment data. They handle the complexity of data formatting and user interactions.

### Question Components (`components/questions/`)

Specialized components for health assessment data collection:
- Different types for different data (single select, multi-select, numeric, date, etc.)
- Built-in validation and error handling
- Consistent UX across all question types
- Support for required/optional fields

**When to use:** Use these when building health assessments, surveys, or forms that collect medical data.

## üìù Common Patterns

### Pattern 1: Form Building

Combine multiple question components to build forms:

```typescript
import {
  SingleSelectQuestion,
  TextQuestion,
  NumericInput
} from "@orion/task-system";

function HealthAssessment() {
  const [answers, setAnswers] = useState({});

  return (
    <View>
      <SingleSelectQuestion
        question={painLevelQuestion}
        answer={answers.painLevel}
        onAnswerChange={(val) => 
          setAnswers(prev => ({ ...prev, painLevel: val }))
        }
      />
      
      <NumericInput
        label="Weight"
        unit="kg"
        value={answers.weight}
        onChange={(val) =>
          setAnswers(prev => ({ ...prev, weight: val }))
        }
      />
      
      <TextQuestion
        question={symptomsQuestion}
        answer={answers.symptoms}
        onAnswerChange={(val) =>
          setAnswers(prev => ({ ...prev, symptoms: val }))
        }
      />
    </View>
  );
}
```

### Pattern 2: Task Management

Display and interact with tasks:

```typescript
import { TaskCard, GroupedTasksView } from "@orion/task-system";

function TaskList() {
  const tasks = useTasks(); // Your data fetching hook

  return (
    <GroupedTasksView
      tasks={tasks}
      onTaskPress={(task) => {
        // Navigate to task details
        navigation.navigate("TaskDetails", { taskId: task.id });
      }}
      onTaskComplete={(task) => {
        // Mark task as complete
        TaskService.completeTask(task.id);
      }}
    />
  );
}
```

### Pattern 3: Conditional Rendering

Show different components based on state:

```typescript
import { LoadingSpinner, Card, Button } from "@orion/task-system";

function MyScreen() {
  const { data, loading, error } = useData();

  if (loading) {
    return <LoadingSpinner />;
  }

  if (error) {
    return (
      <Card>
        <Text>Error: {error.message}</Text>
        <Button title="Retry" onPress={refetch} />
      </Card>
    );
  }

  return <DataView data={data} />;
}
```

## üé® Styling Best Practices

### 1. Use Theme Colors

Import colors from the constants instead of hardcoding:

```typescript
import { AppColors } from "@orion/task-system/constants/AppColors";

const styles = StyleSheet.create({
  container: {
    backgroundColor: AppColors.powderGray,
    borderColor: AppColors.CIBlue,
  },
});
```

### 2. Responsive Design

Use flexible layouts that adapt to screen sizes:

```typescript
import { Dimensions } from "react-native";

const { width } = Dimensions.get("window");
const isTablet = width > 768;

const styles = StyleSheet.create({
  container: {
    padding: isTablet ? 32 : 16,
    maxWidth: isTablet ? 600 : "100%",
  },
});
```

### 3. Consistent Spacing

Use multiples of 4 or 8 for spacing:

```typescript
const styles = StyleSheet.create({
  container: {
    padding: 16,      // 4 * 4
    margin: 8,        // 4 * 2
    gap: 12,          // 4 * 3
  },
});
```

## ‚ôø Accessibility

### Labels and Hints

Always provide accessible labels:

```typescript
<TextField
  label="Email Address"
  placeholder="you@example.com"
  accessibilityLabel="Email address input field"
  accessibilityHint="Enter your email address"
/>
```

### Screen Reader Support

Test with screen readers enabled:
- iOS: VoiceOver
- Android: TalkBack

### Touch Targets

Ensure interactive elements are at least 44x44 points:

```typescript
const styles = StyleSheet.create({
  button: {
    minHeight: 44,
    minWidth: 44,
    padding: 12,
  },
});
```

## üåç Internationalization

All components support multiple languages through i18next:

```typescript
import { useTaskTranslation } from "@orion/task-system/translations";

function MyComponent() {
  const { t } = useTaskTranslation();

  return (
    <View>
      <Text>{t("common.save")}</Text>
      <Text>{t("task.begin")}</Text>
    </View>
  );
}
```

## üß™ Testing

### Unit Testing Components

Test component behavior:

```typescript
import { render, fireEvent } from "@testing-library/react-native";
import { Button } from "@orion/task-system";

test("button calls onPress when clicked", () => {
  const onPress = jest.fn();
  const { getByText } = render(
    <Button title="Click Me" onPress={onPress} />
  );

  fireEvent.press(getByText("Click Me"));
  expect(onPress).toHaveBeenCalledTimes(1);
});
```

### Snapshot Testing

Ensure components render consistently:

```typescript
import { render } from "@testing-library/react-native";
import { TaskCard } from "@orion/task-system";

test("TaskCard matches snapshot", () => {
  const { toJSON } = render(<TaskCard task={mockTask} />);
  expect(toJSON()).toMatchSnapshot();
});
```

## üìö Additional Resources

- **TypeScript Types** - All components are fully typed
- **Storybook Examples** - Interactive examples for each component
- **Source Code** - Available in `packages/task-system/src/`
- **Tests** - Component tests in `__tests__/` directories

