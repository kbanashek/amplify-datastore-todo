---
description: Development practices including testing, logging, and documentation standards
alwaysApply: true
globs: ["**/*.ts", "**/*.tsx", "**/*.test.ts", "**/*.test.tsx", "**/__tests__/**/*", "DOCS/**/*.md", "README.md"]
---

# Development Practices

## Unit Testing Requirements

- **ALWAYS create unit tests** for any new hooks, services, and components
- **Test files must be created alongside the source files** - not as an afterthought
- **Test file naming convention:**
  - Hooks: `src/hooks/__tests__/useHookName.test.ts`
  - Services: `src/services/__tests__/ServiceName.test.ts`
  - Components: `src/components/__tests__/ComponentName.test.tsx` or `src/components/[category]/__tests__/ComponentName.test.tsx`
- **Test coverage requirements:**
  - **Hooks**: Test all return values, state changes, side effects, and edge cases
  - **Services**: Test all public methods, error handling, and data transformations
  - **Components**: Test rendering, user interactions, props handling, and conditional rendering
- **Testing patterns:**
  - Use Jest and React Testing Library for all tests
  - Mock external dependencies (DataStore, APIs, AsyncStorage, etc.)
  - Test user interactions (clicks, input changes, form submissions)
  - Test error states and loading states
  - Test edge cases (empty data, null values, invalid inputs)
- **When creating new code:**
  1. Create the hook/service/component/utility
  2. **IMMEDIATELY create the corresponding test file** - tests are REQUIRED, not optional
  3. Write tests covering the main functionality
  4. Ensure tests pass before considering the feature complete
- **When refactoring or moving code:**
  1. **ALWAYS update or create unit tests** for moved/refactored code
  2. Update test file paths to match new locations
  3. Update test imports to reflect new module structure
  4. Ensure all existing tests still pass after the move
  5. Add new tests if functionality changes during refactoring
  6. **NO EXCEPTIONS** - refactoring without updating tests is incomplete
- **CRITICAL: ALL new files must have unit tests**
  - **Hooks**: `src/hooks/__tests__/useHookName.test.ts`
  - **Components**: `src/components/__tests__/ComponentName.test.tsx` or `src/components/[category]/__tests__/ComponentName.test.tsx`
  - **Services**: `src/services/__tests__/ServiceName.test.ts`
  - **Utils**: `src/utils/__tests__/utilityName.test.ts`
  - **NO EXCEPTIONS** - if you create a new file, you MUST create its test file immediately
- **Examples:**
  - ‚úÖ Good: Create `src/hooks/useAppointmentList.ts` ‚Üí Create `src/hooks/__tests__/useAppointmentList.test.ts` immediately
  - ‚úÖ Good: Create `src/services/AppointmentService.ts` ‚Üí Create `src/services/__tests__/AppointmentService.test.ts` immediately
  - ‚úÖ Good: Create `src/components/AppointmentCard.tsx` ‚Üí Create `src/components/__tests__/AppointmentCard.test.tsx` immediately
  - ‚ùå Bad: Create hook/service/component without corresponding test file
  - ‚ùå Bad: "I'll add tests later" - tests must be created with the code
- **Test structure:**
  - Use `describe` blocks to group related tests
  - Use descriptive test names that explain what is being tested
  - Follow Arrange-Act-Assert pattern
  - Clean up after tests (clear mocks, reset state, etc.)
- **Required test scenarios:**
  - **Hooks**: Initial state, state updates, side effects, cleanup, error handling
  - **Services**: Method calls, return values, error cases, edge cases (empty arrays, null values)
  - **Components**: Rendering with props, user interactions, conditional rendering, error states, loading states

---

## Logging Standards

### Sequential Initialization Logging

**Purpose:** Provide 100% visibility into app initialization and data loading flow.

**Format:** `[INIT-N]` or `[DATA-N]` prefix with icons and concise messages.

#### Initialization Steps (INIT)

- **INIT-1**: Amplify configuration (synchronous)
- **INIT-2**: RootLayout bootstrap start
- **INIT-3**: Task-system runtime initialization
- **INIT-4**: AWS DataStore start
- **INIT-5**: Temp answer sync service configuration
- **INIT-6**: Auto-flush service start
- **INIT-7**: All initialization complete

#### Data Loading Steps (DATA)

- **DATA-1**: Task data subscription and loading
- **DATA-2**: Appointment data loading
- **DATA-3**: Other data model loading (Questions, Activities, etc.)

### Icon Conventions

**ALWAYS use icons to identify log sources:**

- **üöÄ** - Starting/initialization
- **‚úÖ** - Success/completion
- **‚ùå** - Error/failure
- **‚ö†Ô∏è** - Warning
- **‚òÅÔ∏è** - AWS DataStore/cloud operations
- **üîê** - Authentication/configuration
- **‚öôÔ∏è** - Configuration/setup
- **üìã** - Task data
- **üìÖ** - Appointment data
- **üíæ** - Storage/persistence
- **üîÑ** - Sync/retry operations
- **üì§** - Sending/uploading
- **üì•** - Receiving/downloading
- **üóëÔ∏è** - Deletion/cleanup

### Log Message Format

**Format:** `[ICON] [PLATFORM] [STEP] ServiceName: Concise message`

**Platform must ALWAYS be included:** `[iOS]`, `[Android]`, or `[Web]`

**Examples:**
- ‚úÖ Good: `‚òÅÔ∏è [iOS] [INIT-4] Bootstrap: AWS DataStore started - ready for cloud sync`
- ‚úÖ Good: `üìã [Android] [DATA-1] useTaskList: Received 5 tasks (synced-with-cloud)`
- ‚úÖ Good: `üíæ [Web] [TempAnswerSyncService] Service configured`
- ‚ùå Bad: `‚òÅÔ∏è [INIT-4] Bootstrap: AWS DataStore started` (missing platform)
- ‚ùå Bad: `[TaskService] Setting up DataStore subscription` (no icon, no platform, no step)
- ‚ùå Bad: `Task created` (no context, no service name, no platform)

### Logging Rules

#### DO

- **ALWAYS include platform** (`[iOS]`, `[Android]`, or `[Web]`) in every log message
- **Use step numbers** (`[INIT-N]`, `[DATA-N]`) for sequential operations
- **Include icons** to quickly identify log source and type
- **Be concise** - log essential info only, not full objects
- **Use AWS icons (‚òÅÔ∏è)** for all DataStore/AWS operations
- **Log data counts** instead of full arrays: `Loaded 5 tasks` not `Loaded [full array]`
- **Include status indicators**: `synced-with-cloud`, `local-only`, `queued-for-retry`
- **Use `platformLogger.ts` utilities** (`logWithPlatform`, `logErrorWithPlatform`) for consistent formatting

#### DON'T

- **Don't log without platform identification** - every log must include `[iOS]`, `[Android]`, or `[Web]`
- **Don't use raw `console.log`** - use `logWithPlatform` or `logErrorWithPlatform` from `platformLogger.ts`
- **Don't log full JSON objects** - extract key values only
- **Don't log on every render** - only log state changes and operations
- **Don't log navigation menu rendering** - not part of data flow
- **Don't use generic icons** - use specific icons for context
- **Don't log without step numbers** for initialization/data flow

### Readable JSON Formatting in Logs

**NEVER log JSON blobs directly** - format data as human-readable text instead.

**When logging arrays or objects with multiple items:**
- Format as a readable list in the message itself (using newlines and bullet points)
- Keep metadata minimal (only essential summary info)
- Use multi-line formatted strings for complex data structures

**Examples:**

**‚ùå Bad (JSON blob in metadata):**
```typescript
logWithPlatform("üìã", "", "useTaskList", `Received ${items.length} tasks`, {
  tasks: items.map(t => ({ title: t.title, startTime: t.startTime, ... })), // Creates huge JSON blob
});
```

**‚úÖ Good (formatted list in message):**
```typescript
const taskList = items
  .map(t => {
    const startDate = t.startTimeInMillSec
      ? new Date(t.startTimeInMillSec).toISOString().split("T")[0]
      : "no date";
    return `  ‚Ä¢ ${t.title} (start: ${startDate})`;
  })
  .join("\n");

logWithPlatform(
  "üìã",
  "",
  "useTaskList",
  `Received ${items.length} tasks (synced-with-cloud)\n${taskList}`,
  { status: "synced-with-cloud" } // Minimal metadata
);
```

**Guidelines:**
- Use bullet points (`‚Ä¢`) or dashes (`-`) for list items
- Indent list items with 2 spaces for readability
- Include essential info inline (dates, status, counts)
- Keep metadata objects small (max 3-4 key-value pairs)
- For large arrays (>10 items), consider showing summary + sample items

### Error Logging

**Format:** `‚ùå [PLATFORM] [STEP] ServiceName: Failed to [action] - error message`

**Examples:**
- `‚ùå [iOS] [INIT-1] AmplifyConfig: Failed to configure Amplify - API key missing`
- `‚ùå [Android] [DATA-1.1] TaskService: Initial AWS DataStore query failed - Network error`
- `‚ùå [Web] [DATA] TaskService: Failed to create task in AWS DataStore - Validation error`

**Never log full error objects** - extract message only:
- ‚úÖ Good: Use `logErrorWithPlatform` which automatically extracts error messages
- ‚úÖ Good: `error instanceof Error ? error.message : String(error)`
- ‚ùå Bad: `error` (logs full stack trace and object)
- ‚ùå Bad: `console.error("Error:", error)` (missing platform, missing format)

### Centralized Logging Service

**ALWAYS use the centralized logging service** via the `useLogger` hook to ensure platform identification and consistent formatting:

**For React components and hooks:**
```typescript
import { useLogger } from "../hooks/useLogger";

const MyComponent = () => {
  const logger = useLogger();

  // For regular logs
  logger.info("AWS DataStore started - ready for cloud sync", undefined, "Bootstrap", "INIT-4", "‚òÅÔ∏è");

  // For errors
  logger.error("Failed to configure Amplify", error, "AmplifyConfig", "INIT-1");
};
```

**For services and utilities (non-React code):**
```typescript
import { getLoggingService } from "../services/LoggingService";

const logger = getLoggingService();

// For regular logs
logger.info("AWS DataStore started - ready for cloud sync", undefined, "Bootstrap", "INIT-4", "‚òÅÔ∏è");

// For errors
logger.error("Failed to configure Amplify", error, "AmplifyConfig", "INIT-1");
```

**Service-specific logger (recommended for services):**
```typescript
import { getLoggingService } from "../services/LoggingService";

const logger = getLoggingService().createLogger("TaskService");

// Now all logs automatically use "TaskService" as service name
logger.info("Task created", { taskId: "123" }, "DATA-1", "üìã");
logger.error("Failed to create task", error);
```

**The centralized logging service provides:**
- Automatic platform detection (`[iOS]`, `[Android]`, or `[Web]`)
- Consistent formatting across all logs
- Multiple log providers (console, native, Sentry)
- Native logging support for offline testing (adb logcat)
- Type-safe TypeScript interfaces
- Extensible provider architecture

**NEVER use raw `console.log` or `console.error`** - always use the centralized logging service.

üìñ **For detailed documentation**, see [Logging Service Documentation](DOCS/development/logging-service.md)

---

## Documentation Standards

### Technical Documentation

- **ALWAYS create detailed technical documentation in `DOCS/` directory** for:
  - AWS service configurations and conventions
  - Complex technical concepts that need deep explanation
  - Architecture decisions and patterns
  - Integration details and troubleshooting guides
  - Any content that would make the README too long or cluttered
- **Keep README concise** - Provide brief summaries in README and link to detailed docs in `DOCS/`
- **File naming**: Use descriptive, kebab-case names (e.g., `aws-technical-details.md`, `architecture-decisions.md`)
- **Structure**: Include a table of contents for longer documents
- **Cross-references**: Link from README to detailed docs using markdown links: `[Link Text](DOCS/filename.md#section)`
- **Examples**:
  - ‚úÖ Good: Brief summary in README ‚Üí "üìñ **For detailed information**, see [AWS Technical Details](DOCS/aws-technical-details.md#section)"
  - ‚ùå Bad: 50+ lines of detailed technical content directly in README
  - ‚úÖ Good: `DOCS/aws-technical-details.md` with comprehensive AWS information
  - ‚ùå Bad: All documentation crammed into README.md

### Diagrams

- **ALWAYS use Mermaid diagrams** for architecture, data flow, and system diagrams in documentation
- **NEVER use ASCII art** for diagrams (no box-drawing characters like ‚îå, ‚îÇ, ‚îî, ‚îú, etc.)
- Mermaid diagrams are:
  - More maintainable and readable
  - Render properly in GitHub, GitLab, and most markdown viewers
  - Easier to update and modify
  - Support interactive features in some viewers
- Use appropriate Mermaid diagram types:
  - `graph` or `flowchart` for architecture and data flow diagrams
  - `sequenceDiagram` for interaction sequences
  - `classDiagram` for class relationships
  - `stateDiagram` for state machines
  - `erDiagram` for database schemas
- Include styling for better visual clarity:

  ```mermaid
  graph TB
      A[Component] --> B[Service]
      style A fill:#e1f5ff
      style B fill:#fff4e1
  ```

- Examples:
  - ‚úÖ Good: Mermaid flowchart showing component relationships
  - ‚ùå Bad: ASCII art with box-drawing characters
  - ‚úÖ Good: Mermaid sequence diagram for API interactions
  - ‚ùå Bad: ASCII art showing request/response flow

---

## Project Todos

- **ALWAYS use `DOCS/planning/todos.md` for tracking todos and future work**
- When identifying work that needs to be done:
  - Add it to `DOCS/planning/todos.md` with a clear description
  - Group related todos under descriptive headings
  - Mark completed items with `[x]` instead of deleting them
  - Include file paths, code references, or context when relevant
- **Do NOT** create separate todo files or track todos in code comments
- **Do NOT** use TODO comments in code for tracking work - use `DOCS/planning/todos.md` instead
- Format: `- [ ] Description of task` for incomplete, `- [x] Description` for complete
