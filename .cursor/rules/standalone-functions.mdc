# Standalone Functions Should Be Utilities

**Severity**: Error  
**Applies to**: TypeScript, JavaScript, React Components

## Description

Functions that can operate independently (pure functions, utility functions, helper functions) should **NOT** be defined inside components or other modules. They should be extracted into dedicated utility files with unit test coverage.

## Why This Rule Exists

- **Testability**: Standalone functions are easier to test in isolation
- **Reusability**: Utilities can be shared across multiple components/modules
- **Maintainability**: Centralized utilities are easier to find and update
- **Separation of Concerns**: Components should focus on rendering and user interactions, not business logic
- **Code Organization**: Utilities belong in `utils/` directories, not embedded in components

## What Qualifies as a "Standalone Function"

A function is considered standalone if it:
- Takes inputs and returns outputs without side effects (pure function)
- Does not depend on React hooks, component state, or component props (except as parameters)
- Can be tested independently without rendering a component
- Performs calculations, transformations, validations, or data processing
- Does not directly manipulate the DOM or React elements

## Examples

### ❌ Bad: Function Inside Component

```typescript
// packages/task-system/src/src/components/TaskCard.tsx
export const TaskCard: React.FC<TaskCardProps> = ({ task }) => {
  // ❌ BAD: Standalone function inside component
  const getTaskIcon = (task: Task): { name: string; color: string } => {
    const title = (task.title || "").toLowerCase();
    if (title.includes("medication")) {
      return { name: "pills", color: "#3498db" };
    }
    // ... more logic
  };

  const icon = getTaskIcon(task);
  return <View>...</View>;
};
```

### ✅ Good: Function in Utility File

```typescript
// packages/task-system/src/src/utils/taskIcon.ts
export const getTaskIcon = (task: Task): TaskIconConfig => {
  const title = (task.title || "").toLowerCase();
  if (title.includes("medication")) {
    return { name: "pills", color: "#3498db" };
  }
  // ... more logic
};

// packages/task-system/src/src/components/TaskCard.tsx
import { getTaskIcon } from "../utils/taskIcon";

export const TaskCard: React.FC<TaskCardProps> = ({ task }) => {
  const icon = getTaskIcon(task);
  return <View>...</View>;
};
```

### ✅ Good: Function with Unit Tests

```typescript
// packages/task-system/src/src/utils/__tests__/taskIcon.test.ts
import { getTaskIcon } from "../taskIcon";

describe("getTaskIcon", () => {
  it("should return pills icon for medication tasks", () => {
    const task = { title: "Medication Reminder", taskType: TaskType.SCHEDULED };
    const icon = getTaskIcon(task);
    expect(icon.name).toBe("pills");
  });
  // ... more tests
});
```

## Exceptions

Functions that **MUST** stay in components:
- Event handlers that use component state or props (but should use `useCallback` for memoization)
- Functions that use React hooks (`useState`, `useEffect`, etc.)
- Functions that render JSX or React elements
- Functions that are tightly coupled to component lifecycle

## File Organization

- **Utility files**: `packages/task-system/src/src/utils/[utility-name].ts`
- **Test files**: `packages/task-system/src/src/utils/__tests__/[utility-name].test.ts`
- **Export pattern**: Export named exports from utility files, import in components

## Enforcement

When you encounter a standalone function inside a component:
1. Extract it to a new utility file in `packages/task-system/src/src/utils/`
2. Create a corresponding test file in `packages/task-system/src/src/utils/__tests__/`
3. Write comprehensive unit tests covering all edge cases
4. Update the component to import and use the utility
5. Remove the function from the component

## Related Patterns

- **Pure Functions**: Functions that always return the same output for the same input
- **Utility Functions**: Helper functions that perform common operations
- **Business Logic**: Logic that should be separated from presentation
- **Test-Driven Development**: Write tests first, then implement the utility
