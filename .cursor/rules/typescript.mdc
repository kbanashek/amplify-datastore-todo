---
description: TypeScript best practices and coding standards
alwaysApply: true
globs: ['**/*.ts', '**/*.tsx']
---

# TypeScript Best Practices

- **ALWAYS use TypeScript** - Never use JavaScript (.js) files. All new files must be `.ts` or `.tsx`
- **NEVER use `any` type** - Use proper types, `unknown`, or generics instead
  - ❌ Bad: `function process(data: any) { ... }`
  - ✅ Good: `function process<T>(data: T): T { ... }`
  - ✅ Good: `function process(data: unknown): ProcessedData { ... }`
  - **Error handling**: Always use `unknown` for catch clauses, then narrow with type guards
    - ❌ Bad: `catch (error: any) { console.log(error.message); }`
    - ✅ Good: `catch (error: unknown) { const message = error instanceof Error ? error.message : String(error); }`
- **Use explicit return types** for functions, especially public APIs
  - ✅ Good: `function calculateTotal(items: Item[]): number { ... }`
  - ✅ Good: `const getItems = (): Promise<Item[]> => { ... }`
- **Prefer interfaces over type aliases** for object shapes (interfaces are extendable)
  - ✅ Good: `interface User { id: string; name: string; }`
  - Use type aliases for unions, intersections, or computed types
- **Use strict null checks** - Always handle `null` and `undefined` explicitly
  - ✅ Good: `const name: string | undefined = user?.name;`
  - ✅ Good: `if (value !== null && value !== undefined) { ... }`
- **Avoid type assertions (`as`)** - Prefer type guards or proper type narrowing
  - ❌ Bad: `const value = data as string;`
  - ✅ Good: `if (typeof data === 'string') { const value = data; ... }`
- **Use readonly for immutable data**
  - ✅ Good: `interface Config { readonly apiKey: string; readonly timeout: number; }`
- **Prefer const assertions** for literal types
  - ✅ Good: `const statuses = ['active', 'inactive'] as const;`
- **Use enums or const objects** instead of magic strings
  - ✅ Good: `enum TaskStatus { OPEN = 'OPEN', COMPLETED = 'COMPLETED' }`
  - ✅ Good: `const TaskStatus = { OPEN: 'OPEN', COMPLETED: 'COMPLETED' } as const;`
- **Type all function parameters and return values**
  - ❌ Bad: `function process(data) { return data.value; }`
  - ✅ Good: `function process(data: InputData): OutputData { return data.value; }`
- **Use generics for reusable code** instead of `any`
  - ✅ Good: `function identity<T>(value: T): T { return value; }`
- **Prefer optional chaining and nullish coalescing**
  - ✅ Good: `const name = user?.profile?.name ?? 'Unknown';`
- **Use discriminated unions** for type-safe state management
  - ✅ Good: `type State = { status: 'loading' } | { status: 'success'; data: Data } | { status: 'error'; error: Error };`
- **Avoid `@ts-ignore` and `@ts-expect-error`** - Fix the underlying type issues instead
- **Use utility types** (`Partial`, `Pick`, `Omit`, `Record`, etc.) when appropriate
  - ✅ Good: `type UserUpdate = Partial<Pick<User, 'name' | 'email'>>;`
- **Export types and interfaces** that are used across modules
  - ✅ Good: `export interface User { id: string; name: string; }`
- **Use JSDoc comments** for complex types and public APIs
  - ✅ Good: `/** Processes user data and returns formatted result */ function processUser(user: User): ProcessedUser { ... }`
