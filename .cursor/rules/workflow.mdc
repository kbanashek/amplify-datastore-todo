---
description: Version control, GitHub Actions, and operational workflows
alwaysApply: true
globs: [".github/**/*", "*.yml", "*.yaml"]
---

# Workflow & Operations

## Version Control

### Pre-Commit Checks

- **NEVER allow commits with yarn integrity issues**
  - Pre-commit hook automatically runs `yarn check --integrity`
  - If integrity check fails, commit is blocked
  - Fix by running `yarn install` to sync dependencies
  - This prevents committing with broken dependencies or lockfile mismatches

### Commit Messages

- **ALWAYS** provide meaningful commit messages when using version-bump command
- Commit messages are **REQUIRED** and must be descriptive
- Good examples:
  - "Add task grouping by date and time with icons"
  - "Fix DataStore sync issue for questions"
  - "Update task card UI to match design specifications"
- Bad examples (will be rejected):
  - "update"
  - "changes"
  - "fix"
  - Empty or whitespace-only messages

### Version Bumping

- Use semantic versioning (major.minor.patch)
- Always provide a meaningful commit message when bumping versions
- The version-bump script will validate that commit messages are descriptive

### Push Update Workflow

- **When asked to "push update" or similar**, follow this workflow:
  1. Create a new feature branch (e.g., `feature/description-of-changes`)
  2. Fix any lint issues in modified files
  3. Bump the patch version in `package.json` (e.g., `0.1.1` → `0.1.2`)
  4. Update `CHANGELOG.md` with:
     - New version number and current date (format: `YYYY-MM-DD`)
     - Added/Changed/Fixed sections as appropriate
     - Descriptive entries for all changes
  5. Stage all changes (`git add -A`)
  6. Commit with a meaningful message describing all changes
  7. Push the branch to remote (`git push -u origin <branch-name>`)
  8. Add any requested cursor rules to `.cursor/rules/` directory if specified
- **Always verify lint issues are resolved** before committing
- **Always use the current date** when updating CHANGELOG.md
- **Commit messages must be descriptive** - summarize all changes in the commit

---

## GitHub Actions Workflow Standards

### PR Checks Workflow

**File:** `.github/workflows/pr-checks.yml`

**Purpose:** Run essential checks on all pull requests to ensure code quality before merging.

#### Structure

The PR checks workflow consists of **two separate jobs** that run in parallel:

1. **`lint`** - Runs ESLint to check code quality
   - Job name: `Lint`
   - Command: `yarn lint`
   - Must pass for PR to be mergeable

2. **`unit-tests`** - Runs unit tests with coverage
   - Job name: `Unit Tests`
   - Command: `yarn test --coverage --watchAll=false --passWithNoTests --testPathIgnorePatterns=".*(TranslationService|DataStore|Amplify).*"`
   - Skips AWS-dependent tests in CI environment
   - May continue on error (non-blocking for merge)

#### Naming Convention

**ALWAYS use clear, descriptive job names:**
- ✅ Good: `name: Lint` (clear what it does)
- ✅ Good: `name: Unit Tests` (clear what it does)
- ❌ Bad: `name: Run Unit Tests` (redundant - "Run" is implied)
- ❌ Bad: `name: test` (too generic)
- ❌ Bad: `name: PR Tests` (doesn't indicate what type of tests)

**Workflow name should match purpose:**
- ✅ Good: `name: PR Checks` (indicates it's for PR validation)
- ❌ Bad: `name: PR Tests` (misleading if it also runs lint)

#### Job Separation

**ALWAYS separate lint and tests into different jobs:**
- Allows parallel execution (faster CI)
- Clear visibility of which check failed
- Independent failure handling

**DO NOT combine lint and tests in a single job:**
- ❌ Bad: Single job that runs both `yarn lint` and `yarn test`
- ✅ Good: Separate `lint` and `unit-tests` jobs

#### Trigger Configuration

**PR checks should trigger on:**
```yaml
on:
  pull_request:
    branches:
      - develop
      - main
    types: [opened, synchronize, reopened]
```

**DO NOT trigger on push events for PR checks:**
- PR checks are only needed for pull requests
- Push events should use separate workflows (e.g., test-coverage.yml)

#### Error Handling

**Lint job:**
- Must fail the workflow if lint errors are found
- No `continue-on-error: true` on the lint step

**Unit tests job:**
- May use `continue-on-error: true` if tests are non-critical
- Should still report test results even if some tests fail

#### Coverage

**Coverage is included in the unit-tests job:**
- Use `--coverage` flag in test command
- Upload coverage reports as artifacts (optional)
- Coverage reporting is handled by separate `test-coverage.yml` workflow for push events

### Test Coverage Workflow

**File:** `.github/workflows/test-coverage.yml`

**Purpose:** Generate detailed coverage reports and upload to Codecov on push events.

**Triggers:**
- Push to `main` or `develop` branches
- **NOT** on pull requests (coverage is included in PR checks)

### Best Practices

#### Job Names

- Use clear, action-oriented names
- Avoid redundancy (don't say "Run" when it's implied)
- Match the actual command being executed

#### Workflow Organization

- One workflow per purpose (PR checks, coverage, deployment, etc.)
- Keep workflows focused and single-purpose
- Use descriptive workflow names

#### Parallel Execution

- Separate independent checks into separate jobs
- Jobs run in parallel by default (faster CI)
- Use `needs:` only when jobs must run sequentially

#### CodeArtifact Authentication

- Always configure AWS credentials with `continue-on-error: true`
- Fall back to public npm registry if CodeArtifact auth fails
- Ensure dependencies install successfully even without AWS credentials

#### Example Structure

```yaml
name: PR Checks

on:
  pull_request:
    branches: [develop, main]
    types: [opened, synchronize, reopened]

jobs:
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
      - run: yarn install --frozen-lockfile
      - run: yarn lint

  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
      - run: yarn install --frozen-lockfile
      - run: yarn test --coverage --watchAll=false
```

### Auto Merge Workflow

**File:** `.github/workflows/auto-merge.yml`

**Purpose:** Automatically merge pull requests when all required checks pass and conditions are met.

#### How It Works

1. **Triggers on:**
   - PR opened, synchronized, reopened, or marked ready for review
   - Check suite completion
   - Status updates

2. **Conditions:**
   - Only runs for PRs targeting `develop` or `main` branches
   - Waits for all required status checks to pass
   - Respects branch protection rules (approvals, etc.)

3. **Merge Behavior:**
   - Uses squash merge method
   - Automatically deletes the source branch after merge
   - Adds a comment to the PR when auto-merge is enabled

#### Configuration

The workflow uses `peter-evans/enable-pull-request-automerge@v3` which:
- Automatically waits for all required checks to pass
- Respects branch protection rules
- Handles merge conflicts gracefully
- Only enables auto-merge when PR is ready

#### Merge Method

Currently configured to use **squash merge**:
- Creates a single commit from all PR commits
- Keeps commit history clean
- Can be changed to `merge` or `rebase` if needed

#### Notes

- Auto-merge respects branch protection rules (required approvals, status checks, etc.)
- If checks fail, auto-merge will not be enabled
- The workflow will retry when checks complete
- PRs can still be manually merged if needed

### Common Mistakes to Avoid

1. **Misleading job names** - "Run Unit Tests" when it also runs lint
2. **Combining checks** - Running lint and tests in the same job
3. **Unclear workflow names** - "PR Tests" when it's actually "PR Checks"
4. **Missing error handling** - Not handling CodeArtifact auth failures gracefully
5. **Redundant workflows** - Multiple workflows doing the same thing
6. **Auto-merge without checks** - Always ensure required checks pass before enabling auto-merge
