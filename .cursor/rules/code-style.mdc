---
description: TypeScript best practices, code patterns, and style conventions
alwaysApply: true
globs: ["**/*.ts", "**/*.tsx"]
---

# Code Style & Patterns

## TypeScript Best Practices

- **ALWAYS use TypeScript** - Never use JavaScript (.js) files. All new files must be `.ts` or `.tsx`
- **NEVER use `any` type** - Use proper types, `unknown`, or generics instead
  - ‚ùå Bad: `function process(data: any) { ... }`
  - ‚úÖ Good: `function process<T>(data: T): T { ... }`
  - ‚úÖ Good: `function process(data: unknown): ProcessedData { ... }`
  - **Error handling**: Always use `unknown` for catch clauses, then narrow with type guards
    - ‚ùå Bad: `catch (error: any) { console.log(error.message); }`
    - ‚úÖ Good: `catch (error: unknown) { const message = error instanceof Error ? error.message : String(error); }`
- **Use explicit return types** for functions, especially public APIs
  - ‚úÖ Good: `function calculateTotal(items: Item[]): number { ... }`
  - ‚úÖ Good: `const getItems = (): Promise<Item[]> => { ... }`
- **Prefer interfaces over type aliases** for object shapes (interfaces are extendable)
  - ‚úÖ Good: `interface User { id: string; name: string; }`
  - Use type aliases for unions, intersections, or computed types
- **Use strict null checks** - Always handle `null` and `undefined` explicitly
  - ‚úÖ Good: `const name: string | undefined = user?.name;`
  - ‚úÖ Good: `if (value !== null && value !== undefined) { ... }`
- **Avoid type assertions (`as`)** - Prefer type guards or proper type narrowing
  - ‚ùå Bad: `const value = data as string;`
  - ‚úÖ Good: `if (typeof data === 'string') { const value = data; ... }`
- **Use readonly for immutable data**
  - ‚úÖ Good: `interface Config { readonly apiKey: string; readonly timeout: number; }`
- **Prefer const assertions** for literal types
  - ‚úÖ Good: `const statuses = ['active', 'inactive'] as const;`
- **Use enums or const objects** instead of magic strings
  - ‚úÖ Good: `enum TaskStatus { OPEN = 'OPEN', COMPLETED = 'COMPLETED' }`
  - ‚úÖ Good: `const TaskStatus = { OPEN: 'OPEN', COMPLETED: 'COMPLETED' } as const;`
- **Type all function parameters and return values**
  - ‚ùå Bad: `function process(data) { return data.value; }`
  - ‚úÖ Good: `function process(data: InputData): OutputData { return data.value; }`
- **Use generics for reusable code** instead of `any`
  - ‚úÖ Good: `function identity<T>(value: T): T { return value; }`
- **Prefer optional chaining and nullish coalescing**
  - ‚úÖ Good: `const name = user?.profile?.name ?? 'Unknown';`
- **Use discriminated unions** for type-safe state management
  - ‚úÖ Good: `type State = { status: 'loading' } | { status: 'success'; data: Data } | { status: 'error'; error: Error };`
- **Avoid `@ts-ignore` and `@ts-expect-error`** - Fix the underlying type issues instead
- **Use utility types** (`Partial`, `Pick`, `Omit`, `Record`, etc.) when appropriate
  - ‚úÖ Good: `type UserUpdate = Partial<Pick<User, 'name' | 'email'>>;`
- **Export types and interfaces** that are used across modules
  - ‚úÖ Good: `export interface User { id: string; name: string; }`

---

## JSDoc Documentation Requirements

**ALL functions, hooks, services, and components MUST have proper JSDoc documentation.**

### What Requires JSDoc

| Item | Required JSDoc |
|------|----------------|
| **React hooks** | Module-level + hook function + all returned functions |
| **Services** | Class-level + all public methods |
| **Utility functions** | Function-level with `@param` and `@returns` |
| **React components** | Component-level describing purpose and props |
| **Interfaces/Types** | For public APIs and complex types |

### JSDoc Format

**Basic function:**
```typescript
/**
 * Calculates the total price including tax.
 *
 * @param items - Array of items with prices
 * @param taxRate - Tax rate as a decimal (e.g., 0.08 for 8%)
 * @returns The total price including tax
 */
export const calculateTotal = (items: Item[], taxRate: number): number => {
  // ...
};
```

**React hook:**
```typescript
/**
 * React hook for managing task list with real-time synchronization.
 *
 * Provides reactive task data via DataStore subscriptions and
 * task management operations.
 *
 * @param filters - Optional filters to apply to the task list
 * @returns Object containing task data, loading states, and management operations
 *
 * @example
 * ```tsx
 * const { tasks, loading, handleDeleteTask } = useTaskList();
 * ```
 */
export const useTaskList = (filters?: TaskFilters): UseTaskListReturn => {
  // ...
};
```

**Service class:**
```typescript
/**
 * Service for managing Task entities via AWS DataStore.
 *
 * Provides CRUD operations and real-time subscriptions for tasks.
 *
 * @example
 * ```typescript
 * const task = await TaskService.createTask({ title: "New Task" });
 * ```
 */
export class TaskService {
  /**
   * Creates a new task in the DataStore.
   *
   * @param input - Task creation data
   * @returns The created task
   * @throws Error if creation fails
   */
  static async createTask(input: CreateTaskInput): Promise<Task> {
    // ...
  }
}
```

**Interface with documentation:**
```typescript
/**
 * Return type for the useTaskList hook.
 */
interface UseTaskListReturn {
  /** List of all tasks */
  tasks: Task[];
  /** Whether initial data is still loading */
  loading: boolean;
  /** Error message, or null */
  error: string | null;
  /** Deletes a task by ID */
  handleDeleteTask: (id: string) => Promise<void>;
}
```

### Required JSDoc Tags

| Tag | When to Use |
|-----|-------------|
| `@param` | For each function parameter |
| `@returns` | For non-void return values |
| `@throws` | When function can throw errors |
| `@example` | For complex functions, hooks, and services |
| `@see` | To reference related functions or docs |
| `@template` | For generic type parameters |

### Enforcement

When creating or modifying code:
1. **New functions** - Add JSDoc before implementation
2. **Modified functions** - Update JSDoc if behavior changes
3. **New hooks** - Document hook, return type interface, and all returned functions
4. **New services** - Document class and all public methods
5. **New components** - Document component purpose and props

**‚ùå Bad (no documentation):**
```typescript
export const useTaskList = () => {
  const [tasks, setTasks] = useState<Task[]>([]);
  // ...
};
```

**‚úÖ Good (properly documented):**
```typescript
/**
 * React hook for fetching and managing a list of tasks.
 *
 * @returns Object containing tasks array and loading state
 */
export const useTaskList = (): UseTaskListReturn => {
  const [tasks, setTasks] = useState<Task[]>([]);
  // ...
};
```

---

## Arrow Functions

Prefer **arrow functions** for:
- **React components**
- **hooks** (custom hooks and hook callbacks)
- **event handlers** and callbacks
- **small utilities** and one-off helpers

Prefer **const-assigned arrows** for exported APIs:
- ‚úÖ Good: `export const buildPayload = (input: Input): Output => { ... }`

### React Components

- ‚úÖ Preferred:

```ts
export const MyComponent: React.FC<MyProps> = ({ title }) => {
  return <View />;
};
```

- ‚úÖ Also acceptable (if it reads cleaner):

```ts
export const MyComponent = ({ title }: MyProps): React.ReactElement => {
  return <View />;
};
```

### When `function` is acceptable

Use `function` declarations when they provide a concrete benefit:
- **Function overloads** (often clearer with `function`)
- **Generators** (`function*`)
- **Hoisting is required** (rare; prefer re-ordering instead)
- **Very large utilities** where `function name()` reads materially better

---

## Object Map Pattern

**ALWAYS prefer object maps over switch statements or if-else chains** when mapping values to other values.

### When to Use Object Maps

Use object maps when:
- Mapping one value to another (e.g., status codes to messages, platform to icons, error codes to messages)
- The mapping is static and doesn't require complex logic
- You have 3+ cases to handle
- The logic is a simple lookup/transformation

### Pattern

**‚ùå Bad (switch statement):**
```typescript
function getStatusMessage(status: string): string {
  switch (status) {
    case "pending":
      return "Processing";
    case "completed":
      return "Done";
    case "failed":
      return "Error";
    default:
      return "Unknown";
  }
}
```

**‚ùå Bad (if-else chain):**
```typescript
function getPlatformIcon(platform: string): string {
  if (platform === "ios") {
    return "üçé";
  } else if (platform === "android") {
    return "ü§ñ";
  } else if (platform === "web") {
    return "üåê";
  }
  return "‚ùì";
}
```

**‚úÖ Good (object map):**
```typescript
const STATUS_MESSAGES: Record<string, string> = {
  pending: "Processing",
  completed: "Done",
  failed: "Error",
} as const;

function getStatusMessage(status: string): string {
  return STATUS_MESSAGES[status] ?? "Unknown";
}
```

**‚úÖ Good (object map with function for complex cases):**
```typescript
const PLATFORM_ICONS: Record<string, string> = {
  ios: "üçé",
  android: "ü§ñ",
  web: "üåê",
} as const;

function getPlatformIcon(platform: string): string {
  const baseIcon = PLATFORM_ICONS[platform];
  if (baseIcon) {
    // Handle special cases if needed
    if (platform === "web") {
      // Additional logic for web
    }
    return baseIcon;
  }
  return "‚ùì"; // Fallback
}
```

### Benefits

1. **More readable** - Clear mapping at a glance
2. **Easier to maintain** - Add/remove mappings by editing the object
3. **Type-safe** - TypeScript can infer types from `as const`
4. **Testable** - Easy to test the map separately
5. **Performance** - Object lookup is O(1) vs O(n) for if-else chains

### When NOT to Use Object Maps

Don't use object maps when:
- You need complex logic in each case (use functions or switch)
- You need fall-through behavior (use switch)
- You have only 1-2 cases (if-else is fine)
- The mapping requires side effects (use switch or if-else)

### Examples

**Status mapping:**
```typescript
const LOG_LEVEL_NAMES: Record<LogLevel, string> = {
  [LogLevel.VERBOSE]: "VERBOSE",
  [LogLevel.DEBUG]: "DEBUG",
  [LogLevel.INFO]: "INFO",
  [LogLevel.WARN]: "WARN",
  [LogLevel.ERROR]: "ERROR",
} as const;
```

**Error code mapping:**
```typescript
const ERROR_MESSAGES: Record<string, string> = {
  "E001": "Invalid input",
  "E002": "Network error",
  "E003": "Timeout",
} as const;
```

---

## Path Aliases (Package Imports)

**Within the `@orion/task-system` package**, use path aliases instead of relative imports for better readability and maintainability.

### Available Aliases

| Alias | Path |
|-------|------|
| `@components/*` | `packages/task-system/src/components/*` |
| `@hooks/*` | `packages/task-system/src/hooks/*` |
| `@services/*` | `packages/task-system/src/services/*` |
| `@utils/*` | `packages/task-system/src/utils/*` |
| `@task-types/*` | `packages/task-system/src/types/*` |
| `@constants/*` | `packages/task-system/src/constants/*` |
| `@contexts/*` | `packages/task-system/src/contexts/*` |
| `@translations/*` | `packages/task-system/src/translations/*` |
| `@models/*` | `packages/task-system/src/models/*` |
| `@screens/*` | `packages/task-system/src/screens/*` |
| `@fixtures/*` | `packages/task-system/src/fixtures/*` |
| `@runtime/*` | `packages/task-system/src/runtime/*` |
| `@test-utils/*` | `packages/task-system/src/hooks/__tests__/*` |

**Note:** `@task-types` is used instead of `@types` because `@types/` is reserved by TypeScript for type definition packages.

### Examples

**‚ùå Bad (relative imports):**
```typescript
import { Task } from "../../types/Task";
import { TaskService } from "../../../services/TaskService";
import { getServiceLogger } from "../../utils/serviceLogger";
```

**‚úÖ Good (path aliases):**
```typescript
import { Task } from "@task-types/Task";
import { TaskService } from "@services/TaskService";
import { getServiceLogger } from "@utils/serviceLogger";
```

### Jest Mocks with Path Aliases

When using `jest.mock()`, use the same path aliases:

**‚ùå Bad:**
```typescript
jest.mock("../../services/TaskService", () => ({
  TaskService: { getTasks: jest.fn() },
}));
```

**‚úÖ Good:**
```typescript
jest.mock("@services/TaskService", () => ({
  TaskService: { getTasks: jest.fn() },
}));
```

### Configuration Files

Path aliases are configured in:
- `packages/task-system/tsconfig.json` - TypeScript resolution
- `packages/task-system/tsconfig.build.json` - Build configuration
- `jest.config.js` - Jest module resolution

### When to Use Relative Imports

Use relative imports only for:
- Files in the **same directory** (e.g., `./styles`, `./types`)
- Test mocks in `__mocks__/` directories
- Special cases where relative path is clearer

### Migration Script

A conversion script is available at `scripts/convert-imports.js`:
```bash
# Dry run - show what would change
node scripts/convert-imports.js --dry-run

# Apply changes
node scripts/convert-imports.js
```
